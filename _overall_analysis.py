# -*- coding: utf-8 -*-
"""_Overall analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Py4asDJRK101T7NFNddOpCS6GOcA6hkF
"""

# This part contains all the methods
from dateutil.relativedelta import relativedelta

def increase_frameheight():
  from IPython.display import Javascript
  display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 20000})'''))

def enable_plotly_in_cell():
  import IPython
  from plotly.offline import init_notebook_mode
  display(IPython.core.display.HTML('''<script src="/static/components/requirejs/require.js"></script>'''))
  init_notebook_mode(connected=False)

import pandas as pd
def setFloatFormat(floatFormat):
  pd.options.display.float_format = floatFormat.format

def setNormalFloatFormat():
  pd.options.display.float_format = '{:.2f}'.format

setNormalFloatFormat() #set default 

def loadGeneralSheet():
  worksheet = gc.open('_GeneralSongInfo').sheet1
  rows = worksheet.get_all_values()
  # only load track_title_id, song_release_year, artists
  pdGeneral = pd.DataFrame.from_records(rows[1:],columns=rows[0])
  return pdGeneral.drop(columns=['sheet','start_year','music_style','other'])


def loadSheets(sheetName_musicstyle_pairs, removeIncompleteYear):
  df = pd.DataFrame()
  for sheetName_musicstyle_pair in sheetName_musicstyle_pairs:
    print('loading', sheetName_musicstyle_pair)
    worksheet = gc.open(sheetName_musicstyle_pair[0]).sheet1
    rows = worksheet.get_all_values()
    tempDf = pd.DataFrame.from_records(rows[1:],columns=rows[0])

    # to each row add a column with the sheet name and a column with music style
    tempDf['sheet'] = sheetName_musicstyle_pair[0]
    tempDf['music_style'] = sheetName_musicstyle_pair[1]

    rowsRemoved = 0
    last_distro_year = tempDf['distribution_year'].max()
    if removeIncompleteYear:
        last_distro_year_criterion = tempDf['distribution_year'] == last_distro_year
        last_distro_period = tempDf[last_distro_year_criterion]['distribution_quarter'].max()
        if int(last_distro_period) < 4:
            rowsRemoved = len(tempDf[last_distro_year_criterion])   
            tempDf = tempDf[tempDf['distribution_year'] != last_distro_year]
    
    if rowsRemoved > 0:
        print('Sheet has', len(tempDf.index), 'rows after removing', rowsRemoved, 'rows of', last_distro_year, 'because year is not complete')
    else:
        print('Sheet has', len(tempDf.index), 'rows')       
 
    df = df.append(tempDf, sort=True)
  return df

import numpy as np
def shiftRowBasedOnFirstIndexLargerThenZero(row):
  index = 0
  for value in row:
    if value > 0.00:
      break
    index += 1
  
  if index > 0 and index < len(row):
    resultRow = np.array(list(row[index:]) + [None]*index)  # cast to list otherwise + won't work, the None*index adds index times a None value behind
  else:
    resultRow = row
  return resultRow

def shiftRowBasedOnFirstIndexLargerThenZeroAndSongReleaseYear(row, earliestSongReleaseYear):
  index = 0
  for value in row:
    if value > 0.00:
      break
    index += 1
  
  if index > 0 and index < len(row):
    resultRow = np.array(list(row[index:-1]))
  else:
    resultRow = row[:-1] # don't copy last value because that is the song_release_year

  song_release_year  = row['song_release_year']
  first_distro_year =  row.index[index]
  extraYearsToPreFix = relativedelta(first_distro_year, song_release_year).years
  if extraYearsToPreFix > 0:
    resultRow = np.array(list([None]*extraYearsToPreFix) + list(resultRow))

  # Make sure rows get equal nr of values
  extraYearsToAddAfter = relativedelta(song_release_year, earliestSongReleaseYear).years
  if extraYearsToAddAfter > 0:
     resultRow = np.array(list(resultRow) + [None]*extraYearsToAddAfter)

  return resultRow


import datetime
# yearQuarterStr: 20194 or 2019, quarter is optional
def toDate(yearQuarter):
  yearQuarterStr = str(yearQuarter)

  if (len(yearQuarterStr) > 4):
    monthInt = (int(yearQuarterStr[4]) * 3 - 2) 
    if (monthInt  < 1 | monthInt  > 12):
      print('MonthInt has wrong value:', monthInt, 'yearMonth:', yearMonth)

    return datetime.datetime(year=int(yearQuarterStr[:4]), month=monthInt, day=1).date()
  else:
    return datetime.datetime(year=int(yearQuarterStr[:4]), month=1, day=1).date()

# start with y0 because dollar age can also be 0 years
def toYearMonth(monthNr):
  return 'y' + str(monthNr // 4) + 'q' + str((monthNr%4) + 1)

def toYear(yearNr):
  return 'y' + str(yearNr)

from google.colab import files
def downloadcsv(dataframe, sheetname):
  with open(sheetname, 'w') as f:
    f.write(dataframe.to_csv())
  files.download(sheetname)

import plotly.graph_objs as go
from plotly.offline import iplot
import cufflinks as cf
cf.go_offline()

#!pip install --upgrade --quiet gspread
!pip install google-auth==1.12
from google.colab import auth
auth.authenticate_user()
import gspread
from oauth2client.client import GoogleCredentials
gc = gspread.authorize(GoogleCredentials.get_application_default())

def loadAllSheets(removeIncompleteYears):
  df = loadSheets([("90s R&B Featured in Sitcom Friends - BMI - 22.86", 'TV Film'),
                  ("Akon - Don't Matter - BMI", 'Pop'),
                  ("Anderson .Paak & 50 Cent - BMI - 8.73", 'Hip hop'),
                  ("Anarbor Alt-Rock - BMI", 'Rock'),
                  ('Hip-Hop JID, J. Cole, and Smokepurpp - BMI - 1.76', 'Hip hop'),
                  ('Jason Derulo Pitbull - BMI', 'Pop'),
                  ('J. Cole - BMI - 3.62', 'Hip hop'),
                  ('Kira Isabella Billy Currington - BMI', 'Country'),
                  ('K-Pop, R&B Charlie Wilson, and Pop - BMI - 4.22', 'Various'),
                  ('High Valley - BMI - 5.90', 'Country'),
                  ("Meek Mill's Believe It - BMI", 'Hip hop'),
                  ('Monster - 21 Savage - BMI', 'Hip hop'),
                  ('Production + Dance - BMI', 'Dance'),
                  ('Richie Home Kevin Gates - BMI', 'Hip hop'),
                  ("R&B & K-Pop - BMI", 'Various'),
                  ('Rita Ora, Beyonce - No 2019 2nd half data - BMI', 'Pop'),
                  ("Sean Paul, Jason Derulo + Pitbull - BMI", 'Hip hop'),
                  ("Tim McGraw & Florida Georgia Line - BMI - 1.57", "Country"),
                  ("Tinashe - BMI", 'Hip hop'),
                  ("Trey Songz - BMI", 'Hip hop'),
                  ("Trey Songz & Kevin Gates B.Smyth - BMI - 4.81", "Hip Hop"),
                  ("We are the Messengers - Christian Rock - BMI", 'Christian')], removeIncompleteYears)
  dfAscap = loadSheets([("Anderson .Paak's Bubblin - ASCAP", 'Hip hop'),
                        ("Flogging Molly - ASCAP", 'Rock'),
                        ("Iconic Folk for TV and Film - ASCAP", 'TV Film'), 
                        ("Island Reggae - Common Kings - ASCAP", 'Reggae'),
                        ("K-Pop, R&B Charlie Wilson, and Pop - ASCAP", 'Various'),
                        ('Kevin Gates - ASCAP', 'Hip hop'),
                        ('Nathan Walker - ASCAP', 'Hip hop'), 
                        ("Nicki Minaj & Rihanna - ASCAP", 'Pop'),
                        ('Reo Cragun x Gunplay - ASCAP', 'Hip hop'),
                        ('Stars Go Dim - ASCAP', 'Christian')], removeIncompleteYears) 
  df = df.append(dfAscap, ignore_index = True)
  return df

# for testing purposes
def loadOneSheet(removeIncompleteYears):
  return loadSheets([("Anderson .Paak & 50 Cent - BMI - 8.73", 'Hip hop')], removeIncompleteYears)

removeIncompleteYears = True
df = loadAllSheets(removeIncompleteYears)
#df = loadOneSheet(removeIncompleteYears)

# note 1: sometimes a sheet contains distribution_period instead of distribution_quarter, fix it in the sheet!
# note 2: somtimes a distribution_quarter is 6 or 7, fix this in the sheet!

# distribution period should become a string concatenation of distribution_year and distribution_quarter. 
# Therefore make sure these columns are string, then concatenate values per row in column distribution_period 
# distribution_period value example: 20164 
df['distribution_year'] = df['distribution_year'].astype(str)
df['distribution_quarter'] = df['distribution_quarter'].astype(str)
df['distribution_period'] = df['distribution_year'] + df['distribution_quarter']

# some tracks have different names for its title, e.g track 888977842 is has either track title as IF I DON T HAVE YOU or IF I DON'T HAVE YOU. 
# Select only one value for this, this can be done with transform('first')
df['track_title'] = df.groupby('track_id')['track_title'].transform('first')

df['track_title_id'] = df['track_title'] + ' ' + df['track_id']
# convert string to double
df[["payable_amount"]]  = df[["payable_amount"]].apply(pd.to_numeric)
df[["number_of_plays"]] = df[["number_of_plays"]].apply(pd.to_numeric)

dfGeneral = loadGeneralSheet()
#print(dfGeneral.head().to_string())
df = pd.merge(df, dfGeneral, on='track_title_id')
#print(df.head(500).to_string())

# Import PyDrive and associated libraries.
# This only needs to be done once per notebook.
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# Authenticate and create the PyDrive client.
# This only needs to be done once per notebook.
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

# Download a file based on its file ID.
#
# A file ID looks like: laggVyWshwcyP6kEI-y_W3P8D26sz
file_id = 'REPLACE_WITH_YOUR_FILE_ID'
downloaded = drive.CreateFile({'id': file_id})
print('Downloaded content "{}"'.format(downloaded.GetContentString()))

increase_frameheight()
enable_plotly_in_cell()

dfgSource = df
print('Total number of songs: ', len(df.groupby(['track_title_id'])))

nrOfSongs = 250
top_songs = dfgSource.groupby(['track_title_id', 'distribution_year'])['payable_amount'].sum().unstack('distribution_year').max(axis=1).sort_values(ascending=False).head(nrOfSongs).index.tolist()
# select only the items in top songs
dfgSource = dfgSource[dfgSource['track_title_id'].isin(top_songs)]

def createEarningsTables(columnName, columnNameMethod):
  
  dfg = dfgSource.groupby(['track_title_id', columnName])['payable_amount'].sum().unstack(columnName)
  dfg = dfg.rename(columns = lambda columnNameYearQuarter: toDate(columnNameYearQuarter))
  
  dfgMaxAmount = dfg.max(axis=1) # determine the max amount per row, e.g (axis=1)
  dfgGeneralInfo = dfgMaxAmount.to_frame();
  dfgGeneralInfo.columns = ['Highest earnings in a year']
  #print(dfGeneral)
  dfgSource['distribution_year'] = dfgSource['distribution_year'].astype(int) # for min() method used below
  dfgGeneralInfo['start year'] = dfgSource.groupby(['track_title_id'])['distribution_year'].min()

  dfgGeneralInfo['song_release_year'] = dfgSource.groupby(['track_title_id'])['song_release_year'].first()         # first() means get the first value from the list return from groupby
  dfgGeneralInfo.loc[dfgGeneralInfo["song_release_year"] == '','song_release_year'] = dfgGeneralInfo["start year"] # when song_relase_year has empty value, copy value from start year
  dfgGeneralInfo["song_release_year"] = dfgGeneralInfo["song_release_year"].astype(int)                            # convert to int

  dfgGeneralInfo['music_style'] = dfgSource.groupby(['track_title_id'])['music_style'].first()
  dfgGeneralInfo['sheet'] = dfgSource.groupby(['track_title_id'])['sheet'].first()

  print("The " + str(nrOfSongs) + " highest annual earning songs:\n", dfgGeneralInfo.to_string())
  #downloadcsv(dfgGeneralInfo, "dfgGeneralInfo_" + columnName + ".csv")

  print("\n\nPayable amount per " + columnName + ":\n", dfg.to_string())
  #dfg.transpose().iplot(kind="scatter", xTitle = columnName, yTitle= 'Payable amount', layout=cf.Layout(height=1000, width=1800))
 
  # now create the ratio table, normalized based on the first NaN value
  dfg = dfg.div(dfgMaxAmount, axis=0)  # divide all values in a row by the maximum amount found in that row (= kinda normalization) 
  dfgShifted = dfg.copy();
  dfgShifted['song_release_year'] = pd.to_datetime(dfgGeneralInfo["song_release_year"].astype(int), format="%Y")
  print(dfgShifted.to_string())
  earliestSongReleaseYear = dfgShifted['song_release_year'].min()
  dfgShifted = dfgShifted.apply(lambda row: shiftRowBasedOnFirstIndexLargerThenZeroAndSongReleaseYear(row, earliestSongReleaseYear), axis=1, result_type='expand', raw=True) #shift columns to left/right
  
  # Not needed for year rename colums, but getting column index (get_loc) which is the year number and converting that index to year-month string
  dfgShifted = dfgShifted.rename(columns = lambda x: columnNameMethod(dfgShifted.columns.get_loc(x)))
  
  # make a copy because otherwise the mean calculation includes the count row
  dfgShiftedWithExtra = dfgShifted.copy()
  dfgShiftedWithExtra.loc['count'] = dfgShifted.count()
  dfgShiftedWithExtra.loc['mean'] = dfgShifted.mean()
  dfgShiftedWithExtra.loc['standar dev.'] = dfgShifted.std()
  dfgShiftedWithExtra.loc['min'] = dfgShifted.min()
  dfgShiftedWithExtra.loc['max'] = dfgShifted.max()
  
  setFloatFormat('{:.3f}') # show 3 digits dfgShited table
  import IPython
  print(dfgShiftedWithExtra.to_string())
  #downloadcsv(dfgShiftedWithExtra, "dfgShiftedWithExtra_" + columnName + ".csv")
  setNormalFloatFormat()
  dfgShifted.transpose().iplot(kind="scatter", xTitle = 'Payable amount', yTitle= 'Payable amount', layout=cf.Layout(height=1000, width=1800))

#createEarningsTables('distribution_period', toYearMonth) 
createEarningsTables('distribution_year', toYear)

increase_frameheight()
enable_plotly_in_cell()

dfg = df
top_songs = dfg.groupby(['track_title_id', 'distribution_year'])['payable_amount'].sum().unstack('distribution_year').max(axis=1).sort_values(ascending=False).head(150).index.tolist()
companies = ['SPOTIFY', 'APPLE MUSIC']
print('Checking the nr of plays done with: ', companies)
dfg = dfg[dfg['music_user'].isin(companies)]
dfg = dfg[dfg['track_title_id'].isin(top_songs)].groupby(['track_title_id', 'distribution_period'])['number_of_plays'].sum().unstack('distribution_period')
dfg = dfg.rename(columns = lambda columnNameYearQuarter: toDate(columnNameYearQuarter))

dfgMaxPlaysPerSong = dfg.max(axis=1).sort_values(ascending=False).to_frame()
dfgMaxPlaysPerSong.columns = ['Maximum plays in a quarter']
print(dfgMaxPlaysPerSong.to_string())
print("\n\nNr of plays per quarter:\n", dfg.to_string())
dfg.transpose().iplot(kind="scatter", xTitle = 'Distribution period', yTitle= 'Number of plays', layout=cf.Layout(height=1000, width=1800))
dfg = dfg.div(dfgMaxPlaysPerSong['Maximum plays in a quarter'], axis=0)

dfgShifted = dfg.copy();
dfgShifted = dfgShifted.apply(lambda row: shiftRowBasedOnFirstIndexLargerThenZero(row), axis=1, result_type='expand', raw=True)
dfgShifted = dfgShifted.rename(columns = lambda x: toYearMonth(dfgShifted.columns.get_loc(x) + 1))
print('Number of plays historically\n', dfgShifted.to_string())
dfgShifted.transpose().iplot(kind="scatter", xTitle = 'Period since receiving revenue', yTitle= 'Number of plays', layout=cf.Layout(height=1000, width=1800))

increase_frameheight()
enable_plotly_in_cell()

#Songs waarvan %streaming revenue tenminste 50% bedraagt van (totale revenu -/-international sources)
#Songs waarvan %streaming revenue tenminste 75% bedraagt van (totale revenu -/-international sources) 
#Songs waarvan %streaming revenue tenminste 90% bedraagt van (totale revenu -/-international sources) (even op zoek naar sweetspot tussen waar er nog volume in aantals songs zit en waar je echt correlatie ziet)
unitedStatesOnlyCriterion = df['region'] == 'domestic'
dfUsOnly = df[unitedStatesOnlyCriterion];
top_songs = df.groupby(['track_title_id', 'distribution_year'])['payable_amount'].sum().unstack('distribution_year').max(axis=1).sort_values(ascending=False).head(50).index.tolist()
dfUsOnlyRev = dfUsOnly[dfUsOnly['track_title_id'].isin(top_songs)].groupby(['track_title_id'])['payable_amount'].sum().sort_values(ascending=False).to_frame()
dfUsOnlyRev.columns = ['us_payable_amount']

dfUsOnlyRev['us_streaming_payable_amount'] = dfUsOnly[dfUsOnly['general_source'] == 'STREAMING'].groupby(['track_title_id'])['payable_amount'].sum().fillna(0).sort_values(ascending=False)
dfUsOnlyRev['streamingFraction'] = dfUsOnlyRev['us_streaming_payable_amount'] / dfUsOnlyRev['us_payable_amount']
dfUsOnlyRev = dfUsOnlyRev.sort_values('streamingFraction', ascending=False)
print('Top songs, US payable amounts\n', dfUsOnlyRev.to_string())

import pandas as pd

data = {'id': [1, 1, 2, 2], 'name': ['Name1', 'Name 1', 'Name2', 'Name 2'] }
df = pd.DataFrame(data)
print(df)
df['name'] = df.groupby('id')['name'].transform('first')
print(df)